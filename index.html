<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Universo Animado Realista y Responsivo</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
<canvas id="universo"></canvas>
<script>
const canvas = document.getElementById('universo');
const ctx = canvas.getContext('2d');
let width = window.innerWidth;
let height = window.innerHeight;
canvas.width = width;
canvas.height = height;

// Fondo animado con gradiente sutil
function dibujarFondoAnimado() {
    let t = Date.now() * 0.0001;
    let grad = ctx.createLinearGradient(0, 0, width, height);
    grad.addColorStop(0, "#0a0a1a");
    grad.addColorStop(0.5, "#101020");
    grad.addColorStop(1, "#000");
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, width, height);

    // Estrellas difusas grandes
    for (let i = 0; i < 8; i++) {
        let x = Math.sin(t*2+i)*width*0.5 + width*0.5 + Math.cos(i)*width*0.2;
        let y = Math.cos(t*2+i)*height*0.5 + height*0.5 + Math.sin(i)*height*0.2;
        let r = 80 + Math.sin(t*3+i)*30;
        let gradStar = ctx.createRadialGradient(x, y, 0, x, y, r);
        gradStar.addColorStop(0, "rgba(255,255,255,0.08)");
        gradStar.addColorStop(1, "rgba(0,0,0,0)");
        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI*2);
        ctx.fillStyle = gradStar;
        ctx.fill();
        ctx.restore();
    }
}

// Nebulosa rotativa y animada
let nebulaAngle = 0;
function dibujarNebulosaRotativa() {
    let cx = width*0.6, cy = height*0.4;
    nebulaAngle += 0.002;
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(nebulaAngle);
    let grad = ctx.createRadialGradient(0, 0, 40, 0, 0, 320);
    grad.addColorStop(0, "rgba(120,80,255,0.18)");
    grad.addColorStop(0.5, "rgba(80,0,120,0.08)");
    grad.addColorStop(1, "rgba(0,0,0,0)");
    ctx.globalAlpha = 0.5;
    ctx.beginPath();
    ctx.ellipse(0, 0, 320, 180, 0, 0, Math.PI*2);
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.restore();
}

// Nebulosas adicionales
function dibujarNebulosas() {
    let t = Date.now()*0.0002;
    for(let i=0; i<2; i++) {
        let cx = width*(0.3+i*0.4) + Math.sin(t+i)*80;
        let cy = height*(0.4+i*0.3) + Math.cos(t-i)*60;
        let grad = ctx.createRadialGradient(cx, cy, 40, cx, cy, 180 + i*60);
        grad.addColorStop(0, `rgba(${120+i*40},${80+i*30},255,0.12)`);
        grad.addColorStop(0.5, `rgba(${80+i*20},${0+i*10},120,0.05)`);
        grad.addColorStop(1, "rgba(0,0,0,0)");
        ctx.save();
        ctx.globalAlpha = 0.3-i*0.08;
        ctx.beginPath();
        ctx.arc(cx, cy, 180 + i*60, 0, Math.PI*2);
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.restore();
    }
}

// Estrellas parpadeantes y con destellos
const estrellas = [];
function inicializarEstrellas() {
    estrellas.length = 0;
    for (let i = 0; i < Math.floor(width*height/1200); i++) {
        estrellas.push({
            x: Math.random() * width,
            y: Math.random() * height,
            r: Math.random() * 1.8 + 0.7,
            alpha: Math.random()*0.7+0.3,
            delta: Math.random() * 0.02 + 0.01,
            destello: Math.random() < 0.1
        });
    }
}
inicializarEstrellas();

function dibujarEstrellas() {
    estrellas.forEach(e => {
        e.alpha += e.delta;
        if (e.alpha > 1 || e.alpha < 0.3) e.delta *= -1;
        ctx.save();
        ctx.globalAlpha = e.alpha;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
        ctx.fillStyle = "#fff";
        ctx.shadowColor = "#fff";
        ctx.shadowBlur = e.destello ? 16 : 4;
        ctx.fill();
        ctx.restore();
        // Destello extra
        if (e.destello && Math.random() < 0.02) {
            ctx.save();
            ctx.globalAlpha = 0.2;
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.r*6, 0, Math.PI*2);
            ctx.fillStyle = "#fff";
            ctx.fill();
            ctx.restore();
        }
    });
}

// Constelaciones famosas
const constelaciones = [
    // Orión
    [
        {x: 0.2, y: 0.2},
        {x: 0.22, y: 0.25},
        {x: 0.25, y: 0.22},
        {x: 0.28, y: 0.27},
        {x: 0.3, y: 0.22},
        {x: 0.32, y: 0.18}
    ],
    // Casiopea
    [
        {x: 0.7, y: 0.15},
        {x: 0.72, y: 0.18},
        {x: 0.75, y: 0.16},
        {x: 0.78, y: 0.19},
        {x: 0.8, y: 0.15}
    ],
    // Cruz del Sur
    [
        {x: 0.55, y: 0.8},
        {x: 0.57, y: 0.83},
        {x: 0.59, y: 0.81},
        {x: 0.61, y: 0.85}
    ],
    // Osa Mayor
    [
        {x: 0.15, y: 0.6},
        {x: 0.18, y: 0.62},
        {x: 0.22, y: 0.65},
        {x: 0.26, y: 0.68},
        {x: 0.3, y: 0.7},
        {x: 0.33, y: 0.73},
        {x: 0.36, y: 0.76}
    ],
    // Escorpión
    [
        {x: 0.85, y: 0.7},
        {x: 0.83, y: 0.73},
        {x: 0.81, y: 0.76},
        {x: 0.79, y: 0.78},
        {x: 0.77, y: 0.8},
        {x: 0.75, y: 0.82}
    ]
];

function dibujarConstelaciones() {
    ctx.save();
    ctx.strokeStyle = "rgba(100,180,255,0.5)";
    ctx.lineWidth = 2;
    constelaciones.forEach(grupo => {
        // Conectar las estrellas
        ctx.beginPath();
        grupo.forEach((star, i) => {
            let sx = star.x * width;
            let sy = star.y * height;
            if (i === 0) ctx.moveTo(sx, sy);
            else ctx.lineTo(sx, sy);
        });
        ctx.stroke();
        // Dibujar las estrellas
        grupo.forEach(star => {
            let sx = star.x * width;
            let sy = star.y * height;
            ctx.save();
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.arc(sx, sy, 5, 0, Math.PI*2);
            ctx.fillStyle = "#fff";
            ctx.shadowColor = "#6af";
            ctx.shadowBlur = 12;
            ctx.fill();
            ctx.restore();
        });
    });
    ctx.restore();
}

// Planetas generados por código
const planetas = [
    {x: 0.18, y: 0.82, r: 60, color: '#2e8b57', atm: '#aaffaa', sombra: '#145c36', ang: 0, vel: 0.008, anillos: false, lunas: [{ang:0, dist:90, r:12, color:'#ccc', vel:0.02}]},
    {x: 0.78, y: 0.22, r: 38, color: '#e3c16f', atm: '#fff7aa', sombra: '#bba600', ang: 0, vel: -0.006, anillos: false, lunas: [{ang:0, dist:60, r:8, color:'#eee', vel:-0.018}]},
    {x: 0.62, y: 0.72, r: 28, color: '#c1440e', atm: '#ffd7aa', sombra: '#6e2c13', ang: 0, vel: 0.012, anillos: false, lunas: []},
    {x: 0.42, y: 0.52, r: 40, color: '#e6e6e6', atm: '#d1cfcf', sombra: '#aaa', ang: 0, vel: -0.015, anillos: true, lunas: [
        {ang:0, dist:70, r:14, color:'#bbb', vel:0.025}
    ]}
];

function dibujarPlanetasYLunas() {
    planetas.forEach(p => {
        p.ang += p.vel;
        let px = width*p.x + Math.cos(p.ang) * 18;
        let py = height*p.y + Math.sin(p.ang) * 18;
        // Sombra
        ctx.save();
        ctx.beginPath();
        ctx.arc(px+p.r*0.3, py+p.r*0.3, p.r*0.95, 0, Math.PI*2);
        ctx.fillStyle = p.sombra;
        ctx.globalAlpha = 0.5;
        ctx.fill();
        ctx.restore();
        // Superficie con gradiente
        ctx.save();
        let grad = ctx.createRadialGradient(px-p.r*0.3, py-p.r*0.3, p.r*0.2, px, py, p.r);
        grad.addColorStop(0, "#fff");
        grad.addColorStop(0.3, p.color);
        grad.addColorStop(1, "#222");
        ctx.beginPath();
        ctx.arc(px, py, p.r, 0, Math.PI*2);
        ctx.fillStyle = grad;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 24;
        ctx.fill();
        ctx.restore();
        // Atmósfera
        ctx.save();
        ctx.beginPath();
        ctx.arc(px, py, p.r*1.08, 0, Math.PI*2);
        ctx.strokeStyle = p.atm;
        ctx.globalAlpha = 0.3;
        ctx.lineWidth = 6;
        ctx.stroke();
        ctx.restore();
        // Anillos para el último planeta
        if (p.anillos) {
            ctx.save();
            ctx.strokeStyle = "rgba(255,255,255,0.5)";
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.ellipse(px, py, p.r+22, p.r/2, p.ang, 0, Math.PI*2);
            ctx.stroke();
            ctx.restore();
        }
        // Lunas
        p.lunas.forEach(l => {
            l.ang += l.vel;
            let lx = px + Math.cos(l.ang)*l.dist;
            let ly = py + Math.sin(l.ang)*l.dist;
            ctx.save();
            let gradLuna = ctx.createRadialGradient(lx-l.r*0.3, ly-l.r*0.3, l.r*0.2, lx, ly, l.r);
            gradLuna.addColorStop(0, "#fff");
            gradLuna.addColorStop(0.5, l.color);
            gradLuna.addColorStop(1, "#222");
            ctx.beginPath();
            ctx.arc(lx, ly, l.r, 0, Math.PI*2);
            ctx.fillStyle = gradLuna;
            ctx.shadowColor = "#fff";
            ctx.shadowBlur = 8;
            ctx.globalAlpha = 0.8;
            ctx.fill();
            ctx.restore();
        });
    });
}

// Cometa ultra realista con cola dinámica y nombre GERAL en fuente Orbitron
let cometa = {
    x: width / 2,
    y: height / 2,
    particulas: [],
    color: "#0ff"
};
let objetivo = { x: cometa.x, y: cometa.y };

function dibujarCometa() {
    // Cola de partículas
    cometa.particulas.forEach((p, i) => {
        ctx.save();
        ctx.globalAlpha = p.alpha;
        let grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size*2);
        grad.addColorStop(0, "#fff");
        grad.addColorStop(0.5, "#0ff");
        grad.addColorStop(1, "rgba(0,255,255,0)");
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctx.fillStyle = grad;
        ctx.shadowColor = "#fff";
        ctx.shadowBlur = 18;
        ctx.fill();
        ctx.restore();
    });
    // Cabeza del cometa con brillo y núcleo
    ctx.save();
    let grad = ctx.createRadialGradient(cometa.x, cometa.y, 0, cometa.x, cometa.y, 22);
    grad.addColorStop(0, "#fff");
    grad.addColorStop(0.3, "#0ff");
    grad.addColorStop(1, "rgba(0,255,255,0)");
    ctx.beginPath();
    ctx.arc(cometa.x, cometa.y, 22, 0, Math.PI*2);
    ctx.fillStyle = grad;
    ctx.shadowColor = "#0ff";
    ctx.shadowBlur = 32;
    ctx.fill();
    ctx.restore();
    // Núcleo
    ctx.save();
    ctx.beginPath();
    ctx.arc(cometa.x, cometa.y, 8, 0, Math.PI*2);
    ctx.fillStyle = "#fff";
    ctx.shadowColor = "#0ff";
    ctx.shadowBlur = 12;
    ctx.globalAlpha = 0.8;
    ctx.fill();
    ctx.restore();
    // Nombre GERAL en fuente Orbitron
    ctx.save();
    ctx.font = "bold 2.2vw 'Orbitron', Arial, sans-serif";
    ctx.fillStyle = "#fff";
    ctx.shadowColor = "#0ff";
    ctx.shadowBlur = 12;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.fillText("GERAL", cometa.x + 32, cometa.y + 12);
    ctx.restore();
}
function actualizarCometa() {
    cometa.x += (objetivo.x - cometa.x) * 0.07;
    cometa.y += (objetivo.y - cometa.y) * 0.07;
    // Partículas de la cola
    cometa.particulas.unshift({
        x: cometa.x,
        y: cometa.y,
        alpha: 0.9,
        size: Math.random()*8+4,
        vx: (Math.random()-0.5)*2,
        vy: (Math.random()-0.5)*2
    });
    if (cometa.particulas.length > 60) cometa.particulas.pop();
    cometa.particulas.forEach(p => {
        p.alpha *= 0.92;
        p.x -= (objetivo.x - cometa.x) * 0.12 + p.vx;
        p.y -= (objetivo.y - cometa.y) * 0.12 + p.vy;
    });
}

// Animación principal
function animar() {
    dibujarFondoAnimado();
    dibujarNebulosas();
    dibujarNebulosaRotativa();
    dibujarEstrellas();
    dibujarConstelaciones();
    dibujarPlanetasYLunas();
    dibujarCometa();
    actualizarCometa();
    requestAnimationFrame(animar);
}

// Interactividad
canvas.addEventListener('mousemove', function(e) {
    const rect = canvas.getBoundingClientRect();
    objetivo.x = (e.clientX - rect.left) * (canvas.width / rect.width);
    objetivo.y = (e.clientY - rect.top) * (canvas.height / rect.height);
});

// Responsividad
window.addEventListener('resize', () => {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    inicializarEstrellas();
});

animar();
</script>
</body>
</html>

